import { EventEmitter } from 'node:events';
import net from 'node:net';
import { ConnectionConfig, ConnectionEvent, ConnectionStatus } from '../../shared/types';
import { InputSanitizer } from '../security/InputSanitizer';

interface ConnectionManagerEvents {
  status: (status: ConnectionStatus) => void;
  line: (line: string) => void;
  event: (event: ConnectionEvent) => void;
}

export class ConnectionManager extends EventEmitter {
  private socket: net.Socket | null = null;
  private status: ConnectionStatus = 'disconnected';
  private reconnectTimer: NodeJS.Timeout | null = null;
  private primaryProbeTimer: NodeJS.Timeout | null = null;
  private dataBuffer = '';
  private pendingRecordLine: string | null = null;
  private pendingRecordTimer: NodeJS.Timeout | null = null;
  private activeControllerIndex = 0;
  private stopped = true;

  constructor(private config: ConnectionConfig) {
    super();

    if (this.config.controllerIps.length === 0) {
      throw new Error('At least one controller IP is required');
    }
    if (this.config.concurrentConnections < 1 || this.config.concurrentConnections > 10) {
      throw new Error('MiVB supports between 1 and 10 concurrent SMDR connections');
    }
  }

  override on<U extends keyof ConnectionManagerEvents>(event: U, listener: ConnectionManagerEvents[U]): this {
    return super.on(event, listener);
  }

  getStatus(): ConnectionStatus {
    return this.status;
  }

  getActiveController(): string {
    return this.config.controllerIps[this.activeControllerIndex] ?? this.config.controllerIps[0];
  }

  updateConfig(nextConfig: ConnectionConfig): void {
    const ipsChanged = JSON.stringify(this.config.controllerIps) !== JSON.stringify(nextConfig.controllerIps);
    const portChanged = this.config.port !== nextConfig.port;

    this.config = nextConfig;
    if (this.config.controllerIps.length === 0) {
      throw new Error('At least one controller IP is required');
    }
    if (this.config.concurrentConnections < 1 || this.config.concurrentConnections > 10) {
      throw new Error('MiVB supports between 1 and 10 concurrent SMDR connections');
    }

    if (this.activeControllerIndex >= this.config.controllerIps.length) {
      this.activeControllerIndex = 0;
    }

    if ((ipsChanged || portChanged) && !this.stopped) {
      this.log('info', 'Connection configuration changed. Restarting connection.');
      this.activeControllerIndex = 0; // Reset to primary of new list

      if (this.socket) {
        this.socket.removeAllListeners();
        this.socket.destroy();
        this.socket = null;
      }
      this.clearTimers();
      this.connectCurrent();
    }
  }

  start(): void {
    this.stopped = false;
    this.connectCurrent();
  }

  stop(): void {
    this.stopped = true;
    this.setStatus('disconnected');
    this.clearTimers();
    this.flushPendingRecord();

    if (this.socket) {
      this.socket.removeAllListeners();
      this.socket.destroy();
      this.socket = null;
    }
  }

  private connectCurrent(): void {
    const ip = this.getActiveController();
    if (!InputSanitizer.isWhitelistedIp(ip, this.config.ipWhitelist)) {
      this.log('warn', `Controller ${ip} rejected by whitelist. Rotating.`);
      this.rotateController();
      this.scheduleReconnect();
      return;
    }

    this.setStatus('retrying');
    this.log('info', `Connecting to MiVB ${ip}:${this.config.port}`);

    const socket = new net.Socket();
    socket.setNoDelay(true);
    socket.setKeepAlive(true, 10_000);
    socket.setTimeout(3000);

    socket.connect(this.config.port, ip);

    socket.on('connect', () => {
      this.socket = socket;
      this.dataBuffer = '';
      this.pendingRecordLine = null;
      this.clearPendingRecordTimer();
      this.setStatus('connected');
      this.log('info', `Connected to MiVB ${ip}:${this.config.port}`);

      if (this.activeControllerIndex !== 0 && this.config.autoReconnectPrimary) {
        this.schedulePrimaryProbe();
      }
    });

    socket.on('data', (data: Buffer) => {
      this.dataBuffer += data.toString('utf8');
      const lines = this.dataBuffer.split(/\r?\n/);
      this.dataBuffer = lines.pop() ?? '';

      for (const line of lines) {
        const clean = InputSanitizer.sanitizeLine(line);
        if (clean) this.processIncomingLine(clean);
      }
    });

    socket.on('error', (error) => {
      this.log('error', `Socket error on ${ip}: ${error.message}`);
      socket.destroy();
    });

    socket.on('timeout', () => {
      this.log('warn', `Connection timeout for ${ip}`);
      socket.destroy();
    });

    socket.on('close', () => {
      this.flushPendingRecord();
      if (this.socket === socket) {
        this.socket = null;
      }

      if (this.stopped) {
        this.setStatus('disconnected');
        return;
      }

      this.log('warn', `Connection closed for ${ip}`);
      this.rotateController();
      this.scheduleReconnect();
    });
  }

  private scheduleReconnect(): void {
    this.clearPrimaryProbe();
    if (!this.config.autoReconnect) {
      this.setStatus('disconnected');
      return;
    }

    this.clearReconnectTimer();
    this.setStatus('retrying');
    this.reconnectTimer = setTimeout(() => {
      if (!this.stopped) this.connectCurrent();
    }, this.config.reconnectDelayMs || 5000);
  }

  private schedulePrimaryProbe(): void {
    this.clearPrimaryProbe();
    this.primaryProbeTimer = setTimeout(() => {
      if (this.stopped || this.activeControllerIndex === 0) return;
      this.probePrimaryAndFailback();
    }, this.config.primaryRecheckDelayMs || 60_000);
  }

  private probePrimaryAndFailback(): void {
    const primaryIp = this.config.controllerIps[0];
    if (!primaryIp) return;

    const probe = new net.Socket();
    let switched = false;

    probe.setTimeout(3000);
    probe.connect(this.config.port, primaryIp);

    probe.on('connect', () => {
      switched = true;
      probe.destroy();
      this.log('info', `Primary controller ${primaryIp} recovered. Failing back.`);
      this.failbackToPrimary();
    });

    probe.on('error', () => {
      probe.destroy();
    });

    probe.on('timeout', () => {
      probe.destroy();
    });

    probe.on('close', () => {
      if (!switched) this.schedulePrimaryProbe();
    });
  }

  private failbackToPrimary(): void {
    this.activeControllerIndex = 0;

    if (this.socket) {
      this.socket.removeAllListeners();
      this.socket.destroy();
      this.socket = null;
    }

    this.clearReconnectTimer();
    if (!this.stopped) this.connectCurrent();
  }

  private rotateController(): void {
    if (this.config.controllerIps.length <= 1) return;
    this.activeControllerIndex = (this.activeControllerIndex + 1) % this.config.controllerIps.length;
    this.log('info', `Switching failover target to ${this.getActiveController()}`);
  }

  private clearReconnectTimer(): void {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
  }

  private clearPrimaryProbe(): void {
    if (this.primaryProbeTimer) {
      clearTimeout(this.primaryProbeTimer);
      this.primaryProbeTimer = null;
    }
  }

  private clearTimers(): void {
    this.clearReconnectTimer();
    this.clearPrimaryProbe();
    this.clearPendingRecordTimer();
  }

  private setStatus(status: ConnectionStatus): void {
    this.status = status;
    this.emit('status', status);
  }

  private log(level: ConnectionEvent['level'], message: string): void {
    this.emit('event', { level, message, createdAt: new Date().toISOString() });
  }

  private processIncomingLine(line: string): void {
    if (this.isRecordHeader(line)) {
      this.flushPendingRecord();
      this.pendingRecordLine = line;
      this.schedulePendingRecordFlush();
      return;
    }

    if (this.pendingRecordLine) {
      this.pendingRecordLine = `${this.pendingRecordLine} ${line}`;
      this.schedulePendingRecordFlush();
      return;
    }

    // Fallback for single-line records that do not match known header formats.
    this.emit('line', line);
  }

  private isRecordHeader(line: string): boolean {
    return /^%?(?:\d{2}[/-]\d{2}(?:[/-]\d{2,4})?|\d{4}-\d{2}-\d{2}|\d{6}|\d{8})\s+(?:\d{2}:\d{2}:\d{2}|\d{6})\b/.test(line);
  }

  private schedulePendingRecordFlush(): void {
    this.clearPendingRecordTimer();
    this.pendingRecordTimer = setTimeout(() => {
      this.flushPendingRecord();
    }, 250);
  }

  private clearPendingRecordTimer(): void {
    if (this.pendingRecordTimer) {
      clearTimeout(this.pendingRecordTimer);
      this.pendingRecordTimer = null;
    }
  }

  private flushPendingRecord(): void {
    this.clearPendingRecordTimer();
    if (this.pendingRecordLine) {
      const line = this.pendingRecordLine;
      this.pendingRecordLine = null;
      this.emit('line', line);
    }
  }
}
